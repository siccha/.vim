"------------------------------------------------------------
" Auto Commands
"------------------------------------------------------------
" NONE

"------------------------------------------------------------
" Mappings
"------------------------------------------------------------
" s is overwritten by sneak
nnoremap <A-s> s

augroup MyTermMappings
    autocmd!
    " autocmd TermOpen => only define this map in terminal buffers
    " When running tmux in a terminal emulator and one wants to send <C-A> to
    " tmux, then the terminal emulator can't be in normal mode.
    " If it is in normal mode and registers a <C-A> go into insert mode and resend
    " <C-A>
    autocmd TermOpen * nnoremap <buffer> <C-A> i<C-A>
augroup END

" Where to put these?
noremap <leader>% :let @+=@%<CR>
" TODO make this an operator
noremap gs :source<CR>

"------------------------------------------------------------
" Leader maps
"------------------------------------------------------------
" See :help mapleader
let mapleader=" "

" The plugin CamelCaseMotion is not working atm. In principle <leader> w, e, b
" should be used by CamelCaseMotion

" Mappings to move through buffers
" List all available buffers
noremap <leader>l :buffers<CR>:b 
noremap <leader>b :b 
noremap <leader>f :b 
" Go to last buffer
" noremap <leader>uu :b#<CR> " use <C-6> or <C-^> instead
" Open current working directory
noremap <leader>j :bnext<CR>
noremap <leader>k :bprev<CR>

" Yank and Paste
" Yank line into the OS clipboard
nnoremap <leader>y "+yy
" Yank selection into the OS clipboard
xnoremap <leader>y "+y
" Paste from 'middle mouse button' register
noremap <leader>m "*p

" Map to turn off search highlighting (in addition to <C-l>
nnoremap <leader>/ :nohl<CR>

" Dispatch maps
" mnemonic: r = run
noremap <leader>re :execute "Dispatch" @e<CR>
noremap <leader>rr :execute "Dispatch" @r<CR>
noremap <leader>rt :execute "Dispatch" @t<CR>

" Make
" With latexmk use the -silent option for sane warnings
" map <leader>m :Neomake!<CR>
noremap <leader>m :execute "Dispatch!" @m<CR>

"------------------------------------------------------------
" Command abbreviations (renamings)
" You can use :Q to quit (instead of getting an error msg)
ca Q q
ca QA qa


"------------------------------------------------------------
" Start of what was previously private_mappings
"------------------------------------------------------------
"------------------------------------------------------------
" Plug-In configurations
"------------------------------------------------------------

"------------------------------------------------------------
" YouCompleteMe configuration
let g:ycm_complete_in_comments = 1

"------------------------------------------------------------
" RepeatableMotions configuration
map <Up> <Plug>RepeatMotionUp
map <Down> <Plug>RepeatMotionDown
map <Right> <Plug>RepeatMotionRight
map <Left> <Plug>RepeatMotionLeft

"------------------------------------------------------------
" Tags configuration
nmap <F8> :TagbarToggle<CR>

" tags
noremap <C-[> :tprevious<CR>
noremap <C-\> :tnext<CR>

"------------------------------------------------------------
" Functions
function GrepTagFileAndSearch(name)
    execute "! grep " . a:name . " tags"
    let @/ = '\<' . a:name . '\>'
    normal! n
endfunction
command! -nargs=1 GrepTagFileAndSearch :call GrepTagFileAndSearch(<q-args>)

"------------------------------------------------------------
" Leader maps
"------------------------------------------------------------
" Comment/uncomment a line
noremap <leader>c gcc
" Search backwards for a line without indentation
" Can be used for GAP code to jump to definition of the outermost function.
inoremap <S-space> <ESC>
noremap <leader><space> za
" Delete EOL and following whitespace, if we were in insert mode
" we go back to insert mode afterwards.
inoremap <S-del> <ESC>$a  <del><ESC>dwi
noremap <S-del> $a  <del><ESC>dw
" substitute
noremap <leader>subst :<C-f>i:%s//gc<ESC>2hi

" Remap Y to be similar to C and D
noremap Y y$

"------------------------------------------------------------
" Fugitive maps
" For further Fugitive maps see
noremap <C-F> :silent! /^M\>\\|^U\>\\|^A\><CR>:Git<CR><C-W>L
noremap <C-G> :Git<CR>H/^M\>\\|^U\><CR>
noremap <leader>gc :Git commit<CR>
noremap <leader>ga :Git commit --amend<CR>
noremap <leader><S-G> :Git 
noremap <leader><S-S> :Git switch 
noremap <leader>git :Git 
noremap <leader>gee :Gedit<CR>
noremap <leader>gff :Git! fetch<CR>
noremap <leader>grr :Git rebase --autosquash<CR>
noremap <leader>gri :Git rebase --interactive HEAD~
noremap <leader>grcc :Git rebase --continue<CR>
noremap <leader>gre :Git restructure 
noremap <leader>gree :Git restructure<CR><CR>
noremap <leader>gb :Git blame<CR>
noremap <leader>gstt :Git stash<CR>
noremap <leader>gsp :Git stash pop<CR>
noremap <leader>gll :Git log<CR>
noremap <leader>gln :Git log --decorate --oneline<CR>
noremap <leader>0gln :0Git log --decorate --oneline<CR>
noremap <leader>guu :Git! update<CR>
noremap <leader>gd :Git diff<CR>
noremap <leader>gpp :Git! push<CR>
noremap <leader>gpff :Git! push -f
noremap <leader>gtpp :Git! push --tags
noremap <leader>gtpff :Git! push -f --tags
" Somewhat hacky map to change from diff view to normal view
" of the current buffer
" noremap <leader>gD :diffoff \| windo if &diff \| hide \| endif<CR>:Gedit<CR>

"------------------------------------------------------------
" Splits
" Open terminal split
noremap <leader>vt :vsplit<CR>:terminal<CR>i
" Open small splits
command! NEW new |resize 10
command! -nargs=? -complete=buffer SP sp <args>|resize 10
command! -nargs=? -complete=buffer VS vs <args>|vertical resize 10
" Moving through splits
" These only work when I source the vimrc again. So I put them into a
" hack_mappings file and source that again on startup via an alias.
noremap <C-h> <C-W>h
noremap <C-j> <C-W>j
noremap <C-k> <C-W>k
noremap <C-l> <C-W>l
tnoremap <C-h> <C-\><C-N><C-W>h
tnoremap <C-j> <C-\><C-N><C-W>j
tnoremap <C-k> <C-\><C-N><C-W>k
tnoremap <C-l> <C-\><C-N><C-W>l
" Doesn't work
tnoremap <C-S-h> <C-\><C-N><C-W>h

" Open terminal splits
noremap <C-W>tt :vsplit<CR>:terminal<CR>i
noremap <C-W>ts :split<CR>:terminal<CR>i

noremap <C-W>_ <C-W>_:set cmdheight=2<CR>
noremap <C-W><C--> <C-W>_:set cmdheight=2<CR>
noremap <C-W><C-=> <C-W>=:set cmdheight=2<CR>
noremap <C-W><C-\> <C-W>\|:set cmdheight=2<CR>
noremap <C-W><C-t> :split<CR>:terminal<CR>
"------------------------------------------------------------
" Tabs
" Moving through tabs
" To enable mapping Ctrl+Shift combinations, on iterm2 enable Session >
" Terminal State > modifyOtherKeys mode 1
noremap <C-S-Tab> :tabprevious<CR>
noremap <C-Tab>   :tabnext<CR>
tnoremap <C-S-Tab> <C-\><C-N>:tabprevious<CR>
tnoremap <C-Tab>   <C-\><C-N>:tabnext<CR>
noremap <C-S-h> :echomsg "removed"<CR>
noremap <C-S-l> :echomsg "removed"<CR>

tnoremap <C-S-h> <C-\><C-N>:echomsg "removed"<CR>
tnoremap <C-S-l> <C-\><C-N>:echomsg "removed"<CR>
" Press ctrl+v to see what I need to map to map C-S-Tab
noremap <S-H> :echomsg "removed"<CR>
noremap <S-L> :echomsg "removed"<CR>

noremap <leader>tl :tabmove +1<CR>
noremap <leader>th :tabmove -1<CR>

" Opening and closing tabs
noremap <leader>tt :tabedit %<CR>
noremap <leader>tb :tabedit %<CR>:b
noremap <leader>tee :tabedit 
noremap <leader>tc :tabclose<CR>
noremap <leader>tq :tabclose<CR>
noremap <leader>tre :TabooRename 

" Yank current selection and use it as tab name
noremap <leader>try y:TabooRename <C-F>p

"------------------------------------------------------------
" Maps for terminals and terminal mode
noremap <leader>ter :terminal<CR>i
" Make pasting form registers work in terminal. I have no idea what <expr> does.
tnoremap <expr> <C-\><C-R> '<C-\><C-N>"'.nr2char(getchar()).'pi'
" Make <C-W> exit terminal mode
tnoremap <C-W> <C-\><C-N><C-W><ESC><C-W>
" Doesn't work: tnoremap <C-Q> <C-W><ESC><C-Q>
" Make <C-W> also work in insert mode
inoremap <C-W> <ESC><C-W>

"------------------------------------------------------------
" Quickfix and preview window
" Toggle it, from
" https://stackoverflow.com/questions/11198382/how-to-create-a-key-map-to-open-and-close-the-quickfix-window-in-vim
function! ToggleQuickFix()
    if empty(filter(getwininfo(), 'v:val.quickfix'))
        copen
    else
        cclose
    endif
endfunction
nnoremap <leader>cc :call ToggleQuickFix()<cr>
" Close preview windows
nnoremap <leader>cp :pclose<cr>

"------------------------------------------------------------
" Dispatch-vim
" gap this
noremap `gt :Start gap-master --quitonbreak -c "Test(\"%\");QUIT;"<CR>

"------------------------------------------------------------
" To redraw cursor in nvim when the GAP help confuses it
" call the binary: redraw-cursor-in-nvim

"------------------------------------------------------------
" Save
noremap  <C-s> :w<CR>
inoremap <C-s> <ESC>:w<CR>
noremap  <leader>nw :noautocmd w<CR>
" Save and quit
"noremap   <C-x> :x<CR>
"inoremap  <C-x> <ESC>:x<CR>
" Quit
" Unfortunately <C-w> is already used for working with splits
noremap   <C-q> :q<CR>
inoremap  <C-q> <ESC>:q<CR>

" vim: set ft=vim
